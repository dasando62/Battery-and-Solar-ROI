document.addEventListener('DOMContentLoaded', () => {
    // Global variables for data
    let electricityData = null;
    let solarData = null;
    let myChart;
    let peakPeriodChart;
    let maxHourlyChart;
    let quarterlyAverages = null;

    // Variables to store results for exporting
    let analysisResults = null;
    let analysisConfig = null;
    let analysisBaselineCosts = null;
    let analysisSelectedProviders = null;

    const errorContainer = document.getElementById('error-message-container');

    // --- Helper Functions ---
    function getNumericInput(id, defaultValue = 0) {
        const value = parseFloat(document.getElementById(id).value);
        return isNaN(value) ? defaultValue : value;
    }

    function displayError(message) {
        errorContainer.textContent = message;
    }

    function clearError() {
        errorContainer.textContent = '';
    }
    
    // --- Save/Load Settings ---
    const savableInputIds = [
        "dailyPeak", "dailyShoulder", "dailyOffPeak", "dailySolar", "existingSolarKW", "existingSolarInverter",
        "existingBattery", "existingBatteryInverter", "newSolarKW", "costSolar", "newBattery", "newBatteryInverter",
        "costBattery", "gridOffPeakCharge", "gridChargeThreshold", "gridChargeStartTime", "enableBlackoutSizing",
        "blackoutDuration", "blackoutCoverage", "enableLoan", "loanAmount", "loanInterestRate", "loanTerm",
        "enableDiscountRate", "discountRate", "tariffEscalation", "fitDegradationStartYear", "fitDegradationEndYear",
        "fitMinimumRate", "originDailyCharge", "originPeakRate", "originShoulderRate", "originOffPeakRate",
        "originExport1Rate", "originExport1Limit", "originExport2Rate", "globirdDailyCharge", "globirdPeakRate",
        "globirdShoulderRate", "globirdOffPeakRate", "globirdExport4pm9pmRate", "globirdExport9pm10am2pm4pmRate",
        "globirdExport10am2pmRate", "globirdSuperExportRate", "globirdSuperExportLimit", "globirdZeroHeroCredit",
        "amberDailyCharge", "amberImportRate", "amberExportRate", "amberMembership", "aglDailyCharge", "aglPeakRate",
        "aglShoulderRate", "aglOffPeakRate", "aglExportRate", "numYears", "solarDegradation", "batteryDegradation",
        "noExistingSolar", "manualInputToggle", "debugToggle"
    ];

    document.getElementById("saveSettings").addEventListener("click", () => {
        const settings = {};
        savableInputIds.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                settings[id] = element.type === 'checkbox' ? element.checked : element.value;
            }
        });

        const settingsJson = JSON.stringify(settings, null, 2);
        const blob = new Blob([settingsJson], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'roi_settings.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    });

    document.getElementById("loadSettings").addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const settings = JSON.parse(e.target.result);
                const changeEvent = new Event('change');

                for (const id in settings) {
                    const element = document.getElementById(id);
                    if (element) {
                        if (element.type === 'checkbox') {
                            element.checked = settings[id];
                            // Dispatch change event to trigger UI updates (show/hide sections)
                            element.dispatchEvent(changeEvent);
                        } else {
                            element.value = settings[id];
                        }
                    }
                }
                alert("Settings loaded successfully!");
            } catch (error) {
                alert("Failed to load settings. The file may be invalid.");
                console.error("Error loading settings:", error);
            }
        };
        reader.readAsText(file);
        // Clear the input value so the same file can be loaded again
        event.target.value = ''; 
    });


    // --- UI Event Listeners ---
    document.getElementById("debugToggle").addEventListener("change", (e) => {
        const isChecked = e.target.checked;
        document.querySelectorAll(".debug-button").forEach(el => el.style.display = isChecked ? "block" : "none");
        document.querySelectorAll('[id$="DebugTableContainer"]').forEach(el => el.style.display = "none");
    });
    document.getElementById("debugToggle").dispatchEvent(new Event('change'));

    document.getElementById("manualInputToggle").addEventListener("change", (e) => {
        const isChecked = e.target.checked;
        document.getElementById("csvInputSection").style.display = isChecked ? "none" : "block";
        document.getElementById("manualInputSection").style.display = isChecked ? "block" : "none";
    });

    document.getElementById("noExistingSolar").addEventListener("change", (e) => {
        const isChecked = e.target.checked;
        document.getElementById("solarCsvLabel").style.display = isChecked ? "none" : "block";
        if (isChecked && electricityData) {
            solarData = Array(electricityData.length).fill(0);
            document.getElementById('solarCounts').textContent = `Generated ${electricityData.length} days of zero solar records.`;
            quarterlyAverages = calculateQuarterlyAverages();
        } else if (!isChecked) {
            solarData = null;
            quarterlyAverages = null;
            document.getElementById('solarCounts').textContent = '';
            document.getElementById('solarCsv').value = '';
        }
    });
    document.getElementById("noExistingSolar").dispatchEvent(new Event('change'));

    document.getElementById("enableLoan").addEventListener("change", (e) => {
        document.getElementById("loanSettingsContainer").style.display = e.target.checked ? "block" : "none";
    });
    document.getElementById("enableLoan").dispatchEvent(new Event('change'));

    document.getElementById("enableDiscountRate").addEventListener("change", (e) => {
        document.getElementById("discountRateSettingsContainer").style.display = e.target.checked ? "block" : "none";
    });
    document.getElementById("enableDiscountRate").dispatchEvent(new Event('change'));

    document.getElementById("enableBlackoutSizing").addEventListener("change", (e) => {
        document.getElementById("blackoutSettingsContainer").style.display = e.target.checked ? "block" : "none";
    });
    document.getElementById("enableBlackoutSizing").dispatchEvent(new Event('change'));

    document.querySelectorAll(".providerCheckbox").forEach(cb => {
        cb.addEventListener("change", (e) => {
            const settingsDiv = document.getElementById(e.target.value.toLowerCase() + "Settings");
            if (settingsDiv) settingsDiv.style.display = e.target.checked ? "block" : "none";
        });
        const settingsDiv = document.getElementById(cb.value.toLowerCase() + "Settings");
        if(settingsDiv) settingsDiv.style.display = cb.checked ? "block" : "none";
    });

    // --- Data Parsing Functions ---
    function parseElectricityData(csvContent) {
        const data = {};
        const counts = { consumption: 0, feedIn: 0 };
        const lines = csvContent.split('\n').filter(line => line.trim() !== '');
        const headerLine = lines.find(line => line.includes('Usage Type'));
        if (!headerLine) throw new Error("Electricity CSV Error: Header row containing 'Usage Type' not found.");
        const headers = headerLine.split(',').map(h => h.trim().replace(/"/g, ''));
        const usageTypeIndex = headers.indexOf('Usage Type');
        let usageKwhIndex = headers.indexOf('Usage in kWh');
        if (usageKwhIndex === -1) usageKwhIndex = headers.indexOf('Amount Used');
        const fromDateIndex = headers.indexOf('From (date/time)');
        if (usageTypeIndex === -1 || usageKwhIndex === -1 || fromDateIndex === -1) throw new Error("Electricity CSV Error: Required columns not found.");
        const dataLines = lines.slice(lines.indexOf(headerLine) + 1);
        for (const line of dataLines) {
            const columns = line.split(',').map(c => c.trim().replace(/"/g, ''));
            if (columns.length > Math.max(usageTypeIndex, usageKwhIndex, fromDateIndex)) {
                const usageType = columns[usageTypeIndex];
                const usageKWh = parseFloat(columns[usageKwhIndex]);
                const fromDateTimeStr = columns[fromDateIndex].replace(/(\+\d{2}:\d{2}|Z)$/, '');
                const fromDateTime = new Date(fromDateTimeStr);
                if (isNaN(fromDateTime.getTime()) || isNaN(usageKWh)) continue;
                const dateKey = fromDateTime.toISOString().split('T')[0];
                const hour = fromDateTime.getHours();
                if (!data[dateKey]) data[dateKey] = { date: dateKey, consumption: Array(24).fill(0), feedIn: Array(24).fill(0) };
                if (usageType === 'Consumption') {
                    data[dateKey].consumption[hour] += usageKWh;
                    counts.consumption++;
                } else if (usageType === 'Feed In') {
                    data[dateKey].feedIn[hour] += usageKWh;
                    counts.feedIn++;
                }
            }
        }
        return { data: Object.values(data).sort((a, b) => a.date.localeCompare(b.date)), counts };
    }
    function parseSolarData(csvContent) {
        const data = {};
        let count = 0;
        const lines = csvContent.split('\n').filter(line => line.trim() !== '');
        const headerLine = lines.find(line => line.includes('Date/Time'));
        if (!headerLine) throw new Error("Solar CSV Error: Header row containing 'Date/Time' not found.");
        const headers = headerLine.split(',').map(h => h.trim().replace(/"/g, ''));
        const dateIndex = headers.indexOf('Date/Time');
        let generationIndex = headers.indexOf('Generation');
        if (generationIndex === -1) generationIndex = headers.indexOf('Total Generation (kWh)');
        if (dateIndex === -1 || generationIndex === -1) throw new Error("Solar CSV Error: Required columns not found.");
        const dataLines = lines.slice(lines.indexOf(headerLine) + 1);
        for (const line of dataLines) {
            const columns = line.split(',').map(c => c.trim().replace(/"/g, ''));
            if (columns.length > Math.max(dateIndex, generationIndex)) {
                const dateParts = columns[dateIndex].split('.');
                if (dateParts.length !== 3) continue;
                const date = new Date(`${dateParts[2]}-${dateParts[1]}-${dateParts[0]}`);
                const generationKWh = parseFloat(columns[generationIndex]);
                if (isNaN(date.getTime()) || isNaN(generationKWh)) continue;
                const dateKey = date.toISOString().split('T')[0];
                data[dateKey] = generationKWh;
                count++;
            }
        }
        return { data: Object.entries(data).sort((a,b) => a[0].localeCompare(b[0])).map(entry => entry[1]), count };
    }
    function calculateQuarterlyAverages() {
        if (!electricityData || !solarData) return null;
        const quarters = {
            'Q1_Summer': { months: [12, 1, 2], totalPeak: 0, totalShoulder: 0, totalOffPeak: 0, totalSolar: 0, days: 0 },
            'Q2_Autumn': { months: [3, 4, 5], totalPeak: 0, totalShoulder: 0, totalOffPeak: 0, totalSolar: 0, days: 0 },
            'Q3_Winter': { months: [6, 7, 8], totalPeak: 0, totalShoulder: 0, totalOffPeak: 0, totalSolar: 0, days: 0 },
            'Q4_Spring': { months: [9, 10, 11], totalPeak: 0, totalShoulder: 0, totalOffPeak: 0, totalSolar: 0, days: 0 }
        };
        const numDays = Math.min(electricityData.length, solarData.length);
        for (let d = 0; d < numDays; d++) {
            const date = new Date(electricityData[d].date);
            const month = date.getMonth() + 1;
            let dailyPeakConsumption = 0, dailyShoulderConsumption = 0, dailyOffPeakConsumption = 0;
            for (let h = 0; h < 24; h++) {
                const consumption = electricityData[d].consumption[h] || 0;
                if ((h >= 7 && h < 10) || (h >= 16 && h < 22)) dailyPeakConsumption += consumption;
                else if (h >= 10 && h < 16) dailyShoulderConsumption += consumption;
                else dailyOffPeakConsumption += consumption;
            }
            for (const quarter in quarters) {
                if (quarters[quarter].months.includes(month)) {
                    quarters[quarter].totalPeak += dailyPeakConsumption;
                    quarters[quarter].totalShoulder += dailyShoulderConsumption;
                    quarters[quarter].totalOffPeak += dailyOffPeakConsumption;
                    quarters[quarter].totalSolar += solarData[d] || 0;
                    quarters[quarter].days++;
                    break;
                }
            }
        }
        const averages = {};
        for (const quarter in quarters) {
            if (quarters[quarter].days > 0) {
                averages[quarter] = {
                    avgPeak: quarters[quarter].totalPeak / quarters[quarter].days,
                    avgShoulder: quarters[quarter].totalShoulder / quarters[quarter].days,
                    avgOffPeak: quarters[quarter].totalOffPeak / quarters[quarter].days,
                    avgSolar: quarters[quarter].totalSolar / quarters[quarter].days
                };
            }
        }
        return averages;
    }

    document.getElementById('usageCsv').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                clearError();
                const result = parseElectricityData(e.target.result);
                electricityData = result.data;
                document.getElementById('usageCounts').textContent = `Consumption records: ${result.counts.consumption}, Feed In records: ${result.counts.feedIn}`;
                if (document.getElementById('noExistingSolar').checked) {
                    solarData = Array(electricityData.length).fill(0);
                    document.getElementById('solarCounts').textContent = `Generated ${electricityData.length} days of zero solar records.`;
                }
                if (solarData) quarterlyAverages = calculateQuarterlyAverages();
            } catch (error) {
                displayError(error.message);
            }
        };
        reader.readAsText(file);
    });

    document.getElementById('solarCsv').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        document.getElementById('noExistingSolar').checked = false;
        document.getElementById("solarCsvLabel").style.display = 'block';
        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                clearError();
                const result = parseSolarData(e.target.result);
                solarData = result.data;
                document.getElementById('solarCounts').textContent = `Total daily solar records: ${result.count}`;
                if (electricityData) quarterlyAverages = calculateQuarterlyAverages();
            } catch (error) {
                displayError(error.message);
            }
        };
        reader.readAsText(file);
    });
    
    // --- Debug Button Handlers ---
      function hideAllDebugContainers() {
        document.querySelectorAll('[id$="DebugTableContainer"]').forEach(el => el.style.display = "none");
    }

    function generateHourlyConsumptionProfileFromDailyTOU(dailyPeak, dailyShoulder, dailyOffPeak) {
        const hourlyConsumption = Array(24).fill(0);
        const peakHours = 9, shoulderHours = 6, offPeakHours = 9;
        for (let i = 0; i < 24; i++) {
            if ((i >= 7 && i < 10) || (i >= 16 && i < 22)) hourlyConsumption[i] = dailyPeak > 0 ? dailyPeak / peakHours : 0;
            else if (i >= 10 && i < 16) hourlyConsumption[i] = dailyShoulder > 0 ? dailyShoulder / shoulderHours : 0;
            else hourlyConsumption[i] = dailyOffPeak > 0 ? dailyOffPeak / offPeakHours : 0;
        }
        return hourlyConsumption;
    }

    function generateHourlySolarProfileFromDaily(dailyTotal) {
        if (dailyTotal <= 0) return Array(24).fill(0);
        const solarDistribution = [0,0,0,0,0,0,0,0.01,0.05,0.1,0.15,0.19,0.2,0.15,0.1,0.04,0.01,0,0,0,0,0,0,0];
        const distributionTotal = solarDistribution.reduce((a, b) => a + b, 0);
        return solarDistribution.map(val => (val / distributionTotal) * dailyTotal);
    }

    document.getElementById("showDataDebugTable").addEventListener("click", () => {
        if (!document.getElementById("debugToggle").checked) return;
        const useManual = document.getElementById("manualInputToggle").checked;
        if (!useManual && (!electricityData || !solarData || electricityData.length === 0 || solarData.length === 0)) {
            alert("Please upload both electricity and solar CSV files with data first.");
            return;
        }
        hideAllDebugContainers();
        const debugContainer = document.getElementById("dataDebugTableContainer");
        let tableHTML = "<h3>Debug Data (First 100 entries)</h3><table><thead><tr><th>Date</th><th>Hour</th><th>Consumption (kWh)</th><th>Solar (kWh)</th></tr></thead><tbody>";
        const numEntries = useManual ? 1 : Math.min(electricityData.length, 100);
        for (let d = 0; d < numEntries; d++) {
            const dailyPeak = useManual ? getNumericInput("dailyPeak") : 0;
            const dailyShoulder = useManual ? getNumericInput("dailyShoulder") : 0;
            const dailyOffPeak = useManual ? getNumericInput("dailyOffPeak") : 0;
            const dailySolar = useManual ? getNumericInput("dailySolar") : (solarData[d] || 0);
            const hourlyConsumption = useManual ? generateHourlyConsumptionProfileFromDailyTOU(dailyPeak, dailyShoulder, dailyOffPeak) : electricityData[d].consumption;
            const hourlySolar = useManual ? generateHourlySolarProfileFromDaily(dailySolar) : generateHourlySolarProfileFromDaily(solarData[d] || 0);
            for (let h = 0; h < 24; h++) {
                tableHTML += `<tr><td>${useManual ? "Manual Average" : electricityData[d].date}</td><td>${(h<10?'0':'')+h}:00</td><td>${(hourlyConsumption[h] || 0).toFixed(3)}</td><td>${(hourlySolar[h] || 0).toFixed(3)}</td></tr>`;
            }
             if (useManual) break;
        }
        tableHTML += "</tbody></table>";
        debugContainer.innerHTML = tableHTML;
        debugContainer.style.display = "block";
    });

    document.getElementById("showExistingSystemDebugTable").addEventListener("click", () => {
        if (!document.getElementById("debugToggle").checked) return;
        if (document.getElementById("manualInputToggle").checked || !electricityData || !solarData || electricityData.length === 0) {
            alert("This debug table requires uploaded CSV data.");
            return;
        }
        hideAllDebugContainers();
        const debugContainer = document.getElementById("existingSystemDebugTableContainer");
        const totalDays = Math.min(electricityData.length, solarData.length);
        if (totalDays === 0) {
            alert("No overlapping data found.");
            return;
        }
        let totalConsumption = 0, totalSolarGeneration = 0, totalSelfConsumed = 0;
        let totalImported = 0, totalExported = 0;
        for (let d = 0; d < totalDays; d++) {
            const dailySolarKWh = solarData[d] || 0;
            totalSolarGeneration += dailySolarKWh;
            const hourlySolar = generateHourlySolarProfileFromDaily(dailySolarKWh);
            for (let h = 0; h < 24; h++) {
                const consumption = electricityData[d].consumption[h] || 0;
                const solar = hourlySolar[h] || 0;
                totalConsumption += consumption;
                totalSelfConsumed += Math.min(consumption, solar);
                totalImported += Math.max(0, consumption - solar);
                totalExported += Math.max(0, solar - consumption);
            }
        }
        let tableHTML = "<h3>Existing System & Baseline Data</h3><table><thead><tr><th>Parameter</th><th>Value</th></tr></thead><tbody>";
        tableHTML += `<tr><td colspan="2"><strong>Existing System Inputs</strong></td></tr>`;
        tableHTML += `<tr><td>Existing Solar Panel Size (kW)</td><td>${document.getElementById("existingSolarKW").value}</td></tr>`;
        tableHTML += `<tr><td>Existing Solar Inverter Size (kWh)</td><td>${document.getElementById("existingSolarInverter").value}</td></tr>`;
        tableHTML += `<tr><td>Existing Battery Size (kWh)</td><td>${document.getElementById("existingBattery").value}</td></tr>`;
        tableHTML += `<tr><td>Existing Battery Inverter (kW)</td><td>${document.getElementById("existingBatteryInverter").value}</td></tr>`;
        tableHTML += `<tr><td colspan="2"><strong>Baseline Data Analysis (from CSV)</strong></td></tr>`;
        tableHTML += `<tr><td>Total Days Analyzed</td><td>${totalDays} days</td></tr>`;
        tableHTML += `<tr><td>Total Consumption</td><td>${totalConsumption.toFixed(2)} kWh</td></tr>`;
        tableHTML += `<tr><td>Total Solar Generation</td><td>${totalSolarGeneration.toFixed(2)} kWh</td></tr>`;
        tableHTML += `<tr><td>Total Self-Consumed Solar</td><td>${totalSelfConsumed.toFixed(2)} kWh</td></tr>`;
        tableHTML += `<tr><td>Total Imported from Grid</td><td>${totalImported.toFixed(2)} kWh</td></tr>`;
        tableHTML += `<tr><td>Total Exported to Grid</td><td>${totalExported.toFixed(2)} kWh</td></tr>`;
        tableHTML += "</tbody></table>";
        debugContainer.innerHTML = tableHTML;
        debugContainer.style.display = "block";
    });

    document.getElementById("showNewSystemDebugTable").addEventListener("click", () => {
        if (!document.getElementById("debugToggle").checked) return;
        if (document.getElementById("manualInputToggle").checked || !electricityData || !solarData || electricityData.length === 0) {
            alert("This debug table requires uploaded CSV data.");
            return;
        }
        hideAllDebugContainers();
        const debugContainer = document.getElementById("newSystemDebugTableContainer");
        const blackoutSizingEnabled = document.getElementById("enableBlackoutSizing").checked;
        const gridChargeEnabled = document.getElementById("gridOffPeakCharge").checked;

        const dailyPeakPeriodData = [], dailyMaxHourData = [];
        let totalGridChargeForDebug = 0;
        const totalDays = electricityData.length;
        
        for (let d = 0; d < totalDays; d++) {
            let dailyPeakPeriodKWh = 0, dailyMaxHourKWh = 0;
            let batterySOC = 0;
            const newBatterySize = getNumericInput('newBattery', 0);
            
            const dailySolarKWh = (solarData[d] || 0) + (getNumericInput('newSolarKW') * 4);
            const hourlySolar = generateHourlySolarProfileFromDaily(dailySolarKWh);

            for (let h = 0; h < 24; h++) {
                const consumption = electricityData[d].consumption[h] || 0;
                dailyMaxHourKWh = Math.max(dailyMaxHourKWh, consumption);
                if ((h >= 7 && h < 10) || (h >= 16 && h < 22)) {
                    dailyPeakPeriodKWh += consumption;
                }

                const netEnergy = hourlySolar[h] - consumption;
                if (netEnergy > 0) {
                    const chargeAmount = Math.min(netEnergy, newBatterySize - batterySOC);
                    batterySOC += chargeAmount;
                } else {
                    const dischargeAmount = Math.min(Math.abs(netEnergy), batterySOC);
                    batterySOC -= dischargeAmount;
                }
            }
            dailyPeakPeriodData.push(dailyPeakPeriodKWh);
            dailyMaxHourData.push(dailyMaxHourKWh);

            if (gridChargeEnabled) {
                const gridChargeThreshold = getNumericInput('gridChargeThreshold', 0);
                if (batterySOC < gridChargeThreshold) {
                    const chargeNeeded = gridChargeThreshold - batterySOC;
                    const chargeFromGrid = Math.min(chargeNeeded, getNumericInput('newBatteryInverter', 5));
                    totalGridChargeForDebug += chargeFromGrid;
                }
            }
        }

        const avgDailyGridCharge = totalDays > 0 ? totalGridChargeForDebug / totalDays : 0;
        
        const maxPeakPeriod = Math.max(...dailyPeakPeriodData);
        const numBins1 = 10;
        const binSize1 = Math.ceil(maxPeakPeriod / numBins1) || 1;
        const bins1 = Array.from({ length: numBins1 }, (_, i) => ({ label: `${i * binSize1}-${(i + 1) * binSize1} kWh`, count: 0 }));
        dailyPeakPeriodData.forEach(value => {
            const binIndex = Math.min(Math.floor(value / binSize1), numBins1 - 1);
            if(bins1[binIndex]) bins1[binIndex].count++;
        });
        const ctx1 = document.getElementById("peakPeriodHistogram").getContext("2d");
        if (peakPeriodChart) peakPeriodChart.destroy();
        peakPeriodChart = new Chart(ctx1, { type: 'bar', data: { labels: bins1.map(b => b.label), datasets: [{ label: 'Number of Days', data: bins1.map(b => b.count), backgroundColor: 'rgba(0, 123, 255, 0.5)' }] }, options: { plugins: { title: { display: true, text: 'Daily Peak Period Consumption' } } } });
        
        const maxHourly = Math.max(...dailyMaxHourData);
        const numBins2 = 10;
        const binSize2 = Math.ceil(maxHourly / numBins2 * 10) / 10 || 1;
        const bins2 = Array.from({ length: numBins2 }, (_, i) => ({ label: `${(i * binSize2).toFixed(1)}-${((i + 1) * binSize2).toFixed(1)} kW`, count: 0 }));
        dailyMaxHourData.forEach(value => {
            const binIndex = Math.min(Math.floor(value / binSize2), numBins2 - 1);
            if(bins2[binIndex]) bins2[binIndex].count++;
        });
        const ctx2 = document.getElementById("maxHourlyHistogram").getContext("2d");
        if (maxHourlyChart) maxHourlyChart.destroy();
        maxHourlyChart = new Chart(ctx2, { type: 'bar', data: { labels: bins2.map(b => b.label), datasets: [{ label: 'Number of Days', data: bins2.map(b => b.count), backgroundColor: 'rgba(40, 167, 69, 0.5)' }] }, options: { plugins: { title: { display: true, text: 'Maximum Hourly Consumption' } } } });
        
        function getPercentile(data, percentile) {
            if (!data || data.length === 0) return 0;
            const sortedData = [...data].sort((a, b) => a - b);
            const index = Math.ceil(percentile * sortedData.length) - 1;
            return sortedData[Math.max(0, index)];
        }
        
        const recommendedBatteryKWh = getPercentile(dailyPeakPeriodData, 0.90);
        const recommendedInverterKW = getPercentile(dailyMaxHourData, 0.90);
        const finalBatteryRec = Math.ceil(recommendedBatteryKWh);
        const finalInverterRec = (Math.ceil(recommendedInverterKW * 2) / 2).toFixed(1);
        const batteryCoverageDays = dailyPeakPeriodData.filter(d => d <= finalBatteryRec).length;
        const inverterCoverageDays = dailyMaxHourData.filter(d => d <= finalInverterRec).length;
        
        let recommendationHTML = `<div class="recommendation-section"><h4>Sizing Recommendations (based on 90% coverage)</h4><p><strong>Recommended Battery Capacity: ${finalBatteryRec} kWh</strong><br><small><em>This would have covered peak needs on ${batteryCoverageDays} of ${totalDays} days.</em></small></p><p><strong>Recommended Inverter Power: ${finalInverterRec} kW</strong><br><small><em>This would have met max power demand on ${inverterCoverageDays} of ${totalDays} days.</em></small></p>`;
        
        if (gridChargeEnabled) {
            recommendationHTML += `<p><strong>Average Daily Grid Charge for Battery: ${avgDailyGridCharge.toFixed(2)} kWh</strong><br><small><em>Estimated daily import needed to meet the charge threshold.</em></small></p>`;
        }

        if (blackoutSizingEnabled) {
            const blackoutDuration = getNumericInput('blackoutDuration', 0);
            const blackoutCoverage = getNumericInput('blackoutCoverage', 0) / 100;
            if (blackoutDuration > 0 && blackoutCoverage > 0) {
                const allHours = electricityData.flatMap(d => d.consumption);
                let maxConsumptionInWindow = 0;
                for (let i = 0; i <= allHours.length - blackoutDuration; i++) {
                    const windowSum = allHours.slice(i, i + blackoutDuration).reduce((a, b) => a + b, 0);
                    if (windowSum > maxConsumptionInWindow) maxConsumptionInWindow = windowSum;
                }
                const requiredReserve = maxConsumptionInWindow * blackoutCoverage;
                const totalRecommendedSize = finalBatteryRec + requiredReserve;
                recommendationHTML += `<hr><h4>Blackout Protection Sizing</h4><p>For a <strong>${blackoutDuration}-hour</strong> blackout covering <strong>${blackoutCoverage * 100}%</strong> of usage, a reserve of <strong>${requiredReserve.toFixed(2)} kWh</strong> is needed.</p><p><strong>Total Recommended Size (Savings + Blackout):</strong> ${totalRecommendedSize.toFixed(2)} kWh</p>`;
            }
        }
        recommendationHTML += `</div>`;
        document.getElementById("recommendationContainer").innerHTML = recommendationHTML;
        document.getElementById("newSystemEstimatesTable").innerHTML = '';
        debugContainer.style.display = "block";
    });

    document.getElementById("showProvidersDebugTable").addEventListener("click", () => {
        if (!document.getElementById("debugToggle").checked) return;
        const useManual = document.getElementById("manualInputToggle").checked;
        if (!useManual && (!electricityData || !solarData || electricityData.length === 0 || solarData.length === 0)) {
            alert("Please upload CSV files or use manual mode.");
            return;
        }
        hideAllDebugContainers();
        const debugContainer = document.getElementById("providersDebugTableContainer");
        let tableHTML = "<h3>Provider & Tariff Inputs</h3><table><tbody>";
        if (useManual) {
            tableHTML += `<tr><td colspan="2"><strong>Manual Averages (Daily)</strong></td></tr>`;
            tableHTML += `<tr><td>Avg Peak Consumption (kWh)</td><td>${(getNumericInput("dailyPeak")).toFixed(2)}</td></tr>`;
            tableHTML += `<tr><td>Avg Shoulder Consumption (kWh)</td><td>${(getNumericInput("dailyShoulder")).toFixed(2)}</td></tr>`;
            tableHTML += `<tr><td>Avg Off-Peak Consumption (kWh)</td><td>${(getNumericInput("dailyOffPeak")).toFixed(2)}</td></tr>`;
            tableHTML += `<tr><td>Avg Solar Generation (kWh)</td><td>${(getNumericInput("dailySolar")).toFixed(2)}</td></tr>`;
        } else if (quarterlyAverages) {
            tableHTML += `<tr><td colspan="2"><strong>Quarterly Averages (Daily, from CSV)</strong></td></tr>`;
            for (const quarter in quarterlyAverages) {
                const q = quarterlyAverages[quarter];
                tableHTML += `<tr><td>${quarter.replace('_', ' ')} Avg Peak</td><td>${(q.avgPeak).toFixed(2)} kWh</td></tr>`;
                tableHTML += `<tr><td>${quarter.replace('_', ' ')} Avg Shoulder</td><td>${(q.avgShoulder).toFixed(2)} kWh</td></tr>`;
                tableHTML += `<tr><td>${quarter.replace('_', ' ')} Avg Off-Peak</td><td>${(q.avgOffPeak).toFixed(2)} kWh</td></tr>`;
                tableHTML += `<tr><td>${quarter.replace('_', ' ')} Avg Solar</td><td>${(q.avgSolar).toFixed(2)} kWh</td></tr>`;
            }
        }
        const providers = {
            Origin: ["DailyCharge", "PeakRate", "ShoulderRate", "OffPeakRate", "Export1Rate", "Export1Limit", "Export2Rate"],
            GloBird: ["DailyCharge", "PeakRate", "ShoulderRate", "OffPeakRate", "Export4pm9pmRate", "Export9pm10am2pm4pmRate", "Export10am2pmRate", "SuperExportRate", "SuperExportLimit", "ZeroHeroCredit"],
            Amber: ["DailyCharge", "ImportRate", "ExportRate", "Membership"],
            AGL: ["DailyCharge", "PeakRate", "ShoulderRate", "OffPeakRate", "ExportRate"]
        };
        for (const pName in providers) {
            tableHTML += `<tr><td colspan="2"><strong>${pName}</strong></td></tr>`;
            providers[pName].forEach(field => {
                const el = document.getElementById(pName.toLowerCase() + field);
                if(el) tableHTML += `<tr><td>${field.replace(/([A-Z])/g, ' $1').trim()}</td><td>${el.value}</td></tr>`;
            });
        }
        tableHTML += "</tbody></table>";
        debugContainer.innerHTML = tableHTML;
        debugContainer.style.display = "block";
    });

    document.getElementById("showAnalysisPeriodDebugTable").addEventListener("click", () => {
        if (!document.getElementById("debugToggle").checked) return;
        hideAllDebugContainers();
        const debugContainer = document.getElementById("analysisPeriodDebugTableContainer");
        let tableHTML = "<h3>Analysis Period Inputs</h3><table><tbody>";
        tableHTML += `<tr><td>Number of Years</td><td>${document.getElementById("numYears").value}</td></tr>`;
        tableHTML += `<tr><td>Solar Degradation (% per year)</td><td>${document.getElementById("solarDegradation").value}</td></tr>`;
        tableHTML += `<tr><td>Battery Degradation (% per year)</td><td>${document.getElementById("batteryDegradation").value}</td></tr>`;
        tableHTML += "</tbody></table>";
        debugContainer.innerHTML = tableHTML;
        debugContainer.style.display = "block";
    });

    document.getElementById("showLoanDebugTable").addEventListener("click", () => {
        if (!document.getElementById("debugToggle").checked) return;
        hideAllDebugContainers();
        const debugContainer = document.getElementById("loanDebugTableContainer");
        const P = getNumericInput("loanAmount");
        const annualRate = getNumericInput("loanInterestRate");
        const termYears = getNumericInput("loanTerm");
        if (P === 0 || annualRate === 0 || termYears === 0) {
            debugContainer.innerHTML = "<p>Please enter valid loan details (Amount, Rate, and Term > 0).</p>";
            debugContainer.style.display = "block";
            return;
        }
        const i = (annualRate / 100) / 12;
        const n = termYears * 12;
        const monthlyPayment = P * (i * Math.pow(1 + i, n)) / (Math.pow(1 + i, n) - 1);
        const annualPayment = monthlyPayment * 12;
        let tableHTML = "<h3>Loan Amortization Schedule</h3><table><thead><tr><th>Year</th><th>Annual Repayment</th><th>Cumulative Repayments</th><th>Remaining Balance</th></tr></thead><tbody>";
        let cumulativeRepayments = 0;
        for (let y = 1; y <= termYears; y++) {
            cumulativeRepayments += annualPayment;
            let yearEndBalance = P * (Math.pow(1 + i, n) - Math.pow(1 + i, y * 12)) / (Math.pow(1 + i, n) - 1);
            tableHTML += `<tr><td>${y}</td><td>$${annualPayment.toFixed(2)}</td><td>$${cumulativeRepayments.toFixed(2)}</td><td>$${Math.max(0, yearEndBalance).toFixed(2)}</td></tr>`;
        }
        tableHTML += "</tbody></table>";
        debugContainer.innerHTML = tableHTML;
        debugContainer.style.display = "block";
    });

    document.getElementById("showOpportunityCostDebugTable").addEventListener("click", () => {
        if (!document.getElementById("debugToggle").checked) return;
        hideAllDebugContainers();
        const debugContainer = document.getElementById("opportunityCostDebugTableContainer");
        const costSolar = getNumericInput("costSolar");
        const costBattery = getNumericInput("costBattery");
        const systemCost = costSolar + costBattery;
        const discountRate = getNumericInput("discountRate") / 100;
        const numYears = getNumericInput("numYears", 15);
        let tableHTML = `<h3>Opportunity Cost: Future Value of Initial Capital ($${systemCost.toFixed(2)})</h3><table><thead><tr><th>Year</th><th>Invested Capital Value</th></tr></thead><tbody>`;
        for (let y = 1; y <= numYears; y++) {
            const futureValue = systemCost * Math.pow(1 + discountRate, y);
            tableHTML += `<tr><td>${y}</td><td>$${futureValue.toFixed(2)}</td></tr>`;
        }
        tableHTML += "</tbody></table>";
        debugContainer.innerHTML = tableHTML;
        debugContainer.style.display = "block";
    });

    // --- Export Functionality ---
    document.getElementById("exportCsv").addEventListener("click", () => {
        if (!analysisResults) {
            alert("Please run an analysis before exporting.");
            return;
        }
        let csvContent = "data:text/csv;charset=utf-8,";
        const headers = ["Year", `Baseline Cost (${analysisSelectedProviders[0]})`];
        analysisSelectedProviders.forEach(p => {
            headers.push(`${p} Cost w/ System`, `${p} Cumulative Savings`);
        });
        csvContent += headers.join(",") + "\r\n";
        for (let y = 0; y < analysisConfig.numYears; y++) {
            const row = [y + 1, analysisBaselineCosts[y + 1].toFixed(2)];
            analysisSelectedProviders.forEach(p => {
                row.push(analysisResults[p].annualCosts[y].toFixed(2));
                row.push(analysisResults[p].cumulativeSavingsPerYear[y].toFixed(2));
            });
            csvContent += row.join(",") + "\r\n";
        }
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "roi_results.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });

    document.getElementById("exportPdf").addEventListener("click", () => {
        if (!analysisResults) {
            alert("Please run an analysis before exporting.");
            return;
        }
        const { jsPDF } = window.jspdf;
        const resultsSection = document.getElementById("results-section");
        html2canvas(resultsSection, { scale: 2 }).then(canvas => {
            const imgData = canvas.toDataURL('image/png');
            const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const imgHeight = canvas.height * pdfWidth / canvas.width;
            pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, imgHeight);
            pdf.save("roi_results.pdf");
        });
    });

    // --- Analysis Run ---
    document.getElementById("runAnalysis").addEventListener("click", () => {
        clearError();
        document.getElementById("export-controls").style.display = 'none';
        const selectedProviders = Array.from(document.querySelectorAll(".providerCheckbox:checked")).map(cb => cb.value);
        if (selectedProviders.length === 0) {
            alert("Please select at least one provider.");
            return;
        }
        const useManual = document.getElementById("manualInputToggle").checked;
        if (!useManual && (!electricityData || !solarData || electricityData.length === 0)) {
            alert("Please upload valid CSV files with data, or select manual input.");
            return;
        }
        if (!useManual && !quarterlyAverages) {
            quarterlyAverages = calculateQuarterlyAverages();
            if (!quarterlyAverages || Object.keys(quarterlyAverages).length === 0) {
                alert("Could not calculate quarterly averages. Please check your data files.");
                return;
            }
        }
        const config = {
            newSolarKW: getNumericInput("newSolarKW"),
            newBatteryKWH: getNumericInput("newBattery"),
            newBatteryInverterKW: getNumericInput("newBatteryInverter", 5),
            costSolar: getNumericInput("costSolar"),
            costBattery: getNumericInput("costBattery"),
            loanEnabled: document.getElementById("enableLoan").checked,
            discountRateEnabled: document.getElementById("enableDiscountRate").checked,
            loanAmount: getNumericInput("loanAmount"),
            loanInterestRate: getNumericInput("loanInterestRate") / 100,
            loanTerm: getNumericInput("loanTerm"),
            discountRate: getNumericInput("discountRate") / 100,
            numYears: getNumericInput("numYears", 15),
            tariffEscalation: getNumericInput("tariffEscalation", 2) / 100,
            solarDegradation: getNumericInput("solarDegradation", 0.5) / 100,
            batteryDegradation: getNumericInput("batteryDegradation", 2) / 100,
            gridOffPeakCharge: document.getElementById("gridOffPeakCharge").checked,
            gridChargeThreshold: getNumericInput("gridChargeThreshold"),
            gridChargeStartTime: getNumericInput("gridChargeStartTime", 22),
            fitDegradationStartYear: getNumericInput("fitDegradationStartYear", 1),
            fitDegradationEndYear: getNumericInput("fitDegradationEndYear", 10),
            fitMinimumRate: getNumericInput("fitMinimumRate"),
            providers: {
                Origin: { dailyCharge: getNumericInput("originDailyCharge"), peak: getNumericInput("originPeakRate"), shoulder: getNumericInput("originShoulderRate"), offPeak: getNumericInput("originOffPeakRate"), exportTier1: getNumericInput("originExport1Rate"), exportLimit: getNumericInput("originExport1Limit", 14), exportTier2: getNumericInput("originExport2Rate") },
                GloBird: { dailyCharge: getNumericInput("globirdDailyCharge"), peakRate: getNumericInput("globirdPeakRate"), shoulderRate: getNumericInput("globirdShoulderRate"), offPeakRate: getNumericInput("globirdOffPeakRate"), export4pm9pmRate: getNumericInput("globirdExport4pm9pmRate"), export9pm10am2pm4pmRate: getNumericInput("globirdExport9pm10am2pm4pmRate"), export10am2pmRate: getNumericInput("globirdExport10am2pmRate"), superExportRate: getNumericInput("globirdSuperExportRate"), superExportLimit: getNumericInput("globirdSuperExportLimit", 10), zeroHeroCredit: getNumericInput("globirdZeroHeroCredit"), zeroChargeHours: [11, 12, 13] },
                Amber: { dailyCharge: getNumericInput("amberDailyCharge"), importAvg: getNumericInput("amberImportRate"), exportAvg: getNumericInput("amberExportRate"), membership: getNumericInput("amberMembership") },
                AGL: { dailyCharge: getNumericInput("aglDailyCharge"), peakRate: getNumericInput("aglPeakRate"), shoulderRate: getNumericInput("aglShoulderRate"), offPeakRate: getNumericInput("aglOffPeakRate"), exportRate: getNumericInput("aglExportRate") }
            }
        };
        const systemCost = config.costSolar + config.costBattery;
        let annualLoanRepayment = 0;
        if (config.loanEnabled && config.loanAmount > 0 && config.loanInterestRate > 0 && config.loanTerm > 0) {
            const i = config.loanInterestRate / 12;
            const n = config.loanTerm * 12;
            annualLoanRepayment = (config.loanAmount * (i * Math.pow(1 + i, n)) / (Math.pow(1 + i, n) - 1)) * 12;
        }
        const daysPerQuarter = { 'Q1_Summer': 90, 'Q2_Autumn': 91, 'Q3_Winter': 92, 'Q4_Spring': 92 };
        const simulationData = useManual ? { 'Q_Manual': { avgPeak: getNumericInput("dailyPeak"), avgShoulder: getNumericInput("dailyShoulder"), avgOffPeak: getNumericInput("dailyOffPeak"), avgSolar: getNumericInput("dailySolar") } } : quarterlyAverages;
        if(useManual) daysPerQuarter.Q_Manual = 365;
        const firstProvider = selectedProviders[0];
        document.getElementById('baseline-note').textContent = `Note: The 'Baseline Cost' is calculated using the rates of the first selected provider (${firstProvider}).`;
        function getAnnualFit(initialFit, minFit, startYear, endYear, currentYear) {
            if (currentYear < startYear) return initialFit;
            if (currentYear >= endYear) return minFit;
            const degradationPerYear = (initialFit - minFit) / (endYear - startYear);
            return initialFit - (currentYear - startYear + 1) * degradationPerYear;
        }
        const baselineCosts = {};
        for (let y = 1; y <= config.numYears; y++) {
            let annualCost = 0;
            const baselineProvider = config.providers[firstProvider];
            const currentOriginFiT1 = getAnnualFit(config.providers.Origin.exportTier1, config.fitMinimumRate, config.fitDegradationStartYear, config.fitDegradationEndYear, y);
            for (const quarter in simulationData) {
                const qData = simulationData[quarter];
                if (!qData || typeof qData.avgPeak === 'undefined') continue;
                const hourlyConsumption = generateHourlyConsumptionProfileFromDailyTOU(qData.avgPeak, qData.avgShoulder, qData.avgOffPeak);
                const hourlySolar = generateHourlySolarProfileFromDaily(qData.avgSolar);
                for (let d = 0; d < daysPerQuarter[quarter]; d++) {
                    let dailyCost = baselineProvider.dailyCharge;
                    let dailyExport = 0;
                    for (let h = 0; h < 24; h++) {
                        const consumption = hourlyConsumption[h] || 0;
                        const solar = hourlySolar[h] || 0;
                        if (consumption > solar) {
                             const importedKWh = consumption - solar;
                             if ((h >= 7 && h < 10) || (h >= 16 && h < 22)) dailyCost += importedKWh * baselineProvider.peak;
                             else if (h >= 10 && h < 16) dailyCost += importedKWh * baselineProvider.shoulder;
                             else dailyCost += importedKWh * baselineProvider.offPeak;
                        } else {
                            dailyExport += solar - consumption;
                        }
                    }
                    if (dailyExport > 0) {
                        const tier1Amount = Math.min(dailyExport, baselineProvider.exportLimit);
                        dailyCost += tier1Amount * currentOriginFiT1;
                        dailyCost += (dailyExport - tier1Amount) * getAnnualFit(config.providers.Origin.exportTier2, config.fitMinimumRate, config.fitDegradationStartYear, config.fitDegradationEndYear, y);
                    }
                    annualCost += dailyCost;
                }
            }
            baselineCosts[y] = annualCost * Math.pow(1 + config.tariffEscalation, y - 1);
        }
        const results = {};
        selectedProviders.forEach(p => { results[p] = { annualCosts: [], cumulativeSavingsPerYear: [], npv: 0, roiYear: null }; });
        for (let y = 1; y <= config.numYears; y++) {
            const solarFactor = Math.pow(1 - config.solarDegradation, y - 1);
            const batteryFactor = Math.pow(1 - config.batteryDegradation, y - 1);
            selectedProviders.forEach(p => {
                const provider = config.providers[p];
                let annualCost = provider.membership ? provider.membership * 12 : 0;
                let monthlyExports = 0;
                for (const quarter in simulationData) {
                    const qData = simulationData[quarter];
                    if (!qData || typeof qData.avgPeak === 'undefined') continue;
                    const hourlyConsumption = generateHourlyConsumptionProfileFromDailyTOU(qData.avgPeak, qData.avgShoulder, qData.avgOffPeak);
                    const totalDailySolar = qData.avgSolar + (config.newSolarKW * 4);
                    const hourlySolar = generateHourlySolarProfileFromDaily(totalDailySolar);
                    for (let d = 0; d < daysPerQuarter[quarter]; d++) {
                        let batterySOC = 0;
                        let dailyCost = provider.dailyCharge;
                        if (config.gridOffPeakCharge && batterySOC < config.gridChargeThreshold) {
                            const chargeNeeded = config.gridChargeThreshold - batterySOC;
                            const chargeAmount = Math.min(chargeNeeded, config.newBatteryInverterKW);
                            if (chargeAmount > 0) {
                                batterySOC += chargeAmount;
                                let rate = provider.offPeakRate ?? provider.shoulderRate ?? provider.importAvg ?? 0;
                                dailyCost += chargeAmount * rate;
                            }
                        }
                        const hourlyExports = Array(24).fill(0);
                        for (let h = 0; h < 24; h++) {
                            const consumption = hourlyConsumption[h];
                            const solar = hourlySolar[h] * solarFactor;
                            let netLoad = consumption - solar;
                            if (netLoad > 0) {
                                const discharge = Math.min(netLoad, batterySOC);
                                netLoad -= discharge;
                                batterySOC -= discharge;
                                if(netLoad > 0) {
                                     const rate = ((h >= 7 && h < 10) || (h >= 16 && h < 22)) ? (provider.peakRate ?? provider.peak) : (h >= 10 && h < 16) ? (provider.shoulderRate ?? provider.shoulder) : (provider.offPeakRate ?? provider.offPeak);
                                     dailyCost += netLoad * (rate ?? provider.importAvg ?? 0);
                                }
                            } else {
                                const charge = Math.min(-netLoad, (config.newBatteryKWH * batteryFactor) - batterySOC);
                                batterySOC += charge;
                                netLoad += charge;
                                if (netLoad < 0) hourlyExports[h] = -netLoad;
                            }
                        }
                        const dailyExportTotal = hourlyExports.reduce((a, b) => a + b, 0);
                        if(dailyExportTotal > 0){
                            if(p === 'Origin'){
                                const tier1 = Math.min(dailyExportTotal, provider.exportLimit);
                                dailyCost += tier1 * getAnnualFit(provider.exportTier1, config.fitMinimumRate, config.fitDegradationStartYear, config.fitDegradationEndYear, y);
                                dailyCost += (dailyExportTotal - tier1) * getAnnualFit(provider.exportTier2, config.fitMinimumRate, config.fitDegradationStartYear, config.fitDegradationEndYear, y);
                            } else if (p === 'GloBird') {
                                if (d > 0 && d % 30 === 0) monthlyExports = 0;
                                const superAllowance = Math.max(0, (provider.superExportLimit * 30.4) - monthlyExports);
                                const superCreditAmount = Math.min(dailyExportTotal, superAllowance);
                                dailyCost += superCreditAmount * getAnnualFit(provider.superExportRate, config.fitMinimumRate, config.fitDegradationStartYear, config.fitDegradationEndYear, y);
                                monthlyExports += superCreditAmount;
                                for(let h=0; h<24; h++) {
                                    if(hourlyExports[h] > 0){
                                        let exportForHour = hourlyExports[h];
                                        let superPortionInHour = (dailyExportTotal > 0) ? (exportForHour / dailyExportTotal) * superCreditAmount : 0;
                                        let regularPortionInHour = exportForHour - superPortionInHour;
                                        if(regularPortionInHour > 0){
                                             if (h >= 16 && h < 21) dailyCost += regularPortionInHour * getAnnualFit(provider.export4pm9pmRate, config.fitMinimumRate, config.fitDegradationStartYear, config.fitDegradationEndYear, y);
                                             else if ((h >= 21 || h < 10) || (h >= 14 && h < 16)) dailyCost += regularPortionInHour * getAnnualFit(provider.export9pm10am2pm4pmRate, config.fitMinimumRate, config.fitDegradationStartYear, config.fitDegradationEndYear, y);
                                             else if (h >= 10 && h < 14) dailyCost += regularPortionInHour * getAnnualFit(provider.export10am2pmRate, config.fitMinimumRate, config.fitDegradationStartYear, config.fitDegradationEndYear, y);
                                        }
                                    }
                                }
                            } else {
                                dailyCost += dailyExportTotal * getAnnualFit(provider.exportRate ?? provider.exportAvg, config.fitMinimumRate, config.fitDegradationStartYear, config.fitDegradationEndYear, y);
                            }
                        }
                        annualCost += dailyCost;
                    }
                }
                const finalAnnualCost = annualCost * Math.pow(1 + config.tariffEscalation, y - 1);
                results[p].annualCosts.push(finalAnnualCost);
                const annualSavings = baselineCosts[y] - finalAnnualCost;
                const netCashFlow = annualSavings - (y <= config.loanTerm ? annualLoanRepayment : 0);
                const lastYearCumulative = results[p].cumulativeSavingsPerYear[y - 2] || 0;
                const currentCumulative = lastYearCumulative + netCashFlow;
                results[p].cumulativeSavingsPerYear.push(currentCumulative);
                if (!results[p].roiYear && currentCumulative >= systemCost) results[p].roiYear = y;
                results[p].npv += netCashFlow / Math.pow(1 + config.discountRate, y);
            });
        }
        let summaryHTML = "<h3>Return on Investment Summary</h3>";
        selectedProviders.forEach(p => {
            const finalNPV = results[p].npv - (systemCost - config.loanAmount);
            summaryHTML += `<p><strong>${p}</strong></p><ul><li>Payback Period: Year ${results[p].roiYear ? results[p].roiYear : `> ${config.numYears}`}</li>${config.discountRateEnabled ? `<li>Net Present Value (NPV): <strong>$${finalNPV.toFixed(2)}</strong></li>` : ''}</ul>`;
        });
        document.getElementById("roiSummary").innerHTML = summaryHTML;
        let tableHTML = `<h3>Financial Breakdown by Year</h3><table><thead><tr><th>Year</th><th>Baseline Cost (${firstProvider})</th>`;
        selectedProviders.forEach(p => tableHTML += `<th>${p} Cost w/ System</th><th>${p} Cumulative Savings</th>`);
        tableHTML += "</tr></thead><tbody>";
        for (let y = 0; y < config.numYears; y++) {
            tableHTML += `<tr><td>${y + 1}</td><td>$${baselineCosts[y + 1].toFixed(2)}</td>`;
            selectedProviders.forEach(p => {
                const cumulativeSavingForYear = results[p].cumulativeSavingsPerYear[y];
                tableHTML += `<td>$${results[p].annualCosts[y].toFixed(2)}</td><td>$${cumulativeSavingForYear.toFixed(2)}</td>`;
            });
            tableHTML += "</tr>";
        }
        tableHTML += "</tbody></table>";
        document.getElementById("results").innerHTML = tableHTML;
        const datasets = selectedProviders.map(p => ({ label: p, data: results[p].cumulativeSavingsPerYear, borderColor: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'), fill: false }));
        const ctx = document.getElementById("savingsChart").getContext("2d");
        if (myChart) myChart.destroy();
        myChart = new Chart(ctx, { type: 'line', data: { labels: Array.from({ length: config.numYears }, (_, i) => `Year ${i + 1}`), datasets: [{ label: "Capital Outlay", data: Array(config.numYears).fill(systemCost), borderColor: "black", borderDash: [5, 5], fill: false, pointRadius: 0 }, ...datasets] }, options: { responsive: true, plugins: { title: { display: true, text: 'Cumulative Net Savings vs. Initial Cost' } }, scales: { x: { title: { display: true, text: 'Years' } }, y: { title: { display: true, text: 'Cumulative Savings ($)' } } } } });

        analysisResults = results;
        analysisConfig = config;
        analysisBaselineCosts = baselineCosts;
        analysisSelectedProviders = selectedProviders;
        document.getElementById("export-controls").style.display = 'flex';
    });
});